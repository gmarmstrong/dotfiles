#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

dotfiles_path="${HOME}/dotfiles"
flake_path="${HOME}/dotfiles"
hostname=$(hostname -s)
username="${USER}"
log_dir="${HOME}/Library/Logs/system-update/$(date +%Y%m%d-%H%M%S)"
CONFIG_TYPE=""


print_header() {
    printf "\n\033[1m>> %s\033[0m\n" "$1"
}

print_error() {
    printf "\n\033[1;31m✗ Error: %s\033[0m\n" "$1" >&2
}

print_warning() {
    printf "\033[1;33m⚠ Warning: %s\033[0m\n" "$1"
}

run_logged() {
    local operation_name="$1"
    local success_msg="$2"
    shift 2

    mkdir -p "${log_dir}"
    local log_file
    log_file="${log_dir}/${operation_name}.log"

    if "$@" > "${log_file}" 2>&1; then
        printf "%s ✓\n" "${success_msg}"
    else
        print_error "${operation_name} failed"
        tail -n 30 "${log_file}"
        printf "\nFull log: %s\n" "${log_file}"
        exit 1
    fi
}

### Pre-run checks ###

detect_system_type() {
    print_header "Detecting system type..."
    
    if [[ "$(uname)" == "Darwin" ]]; then
        CONFIG_TYPE="darwin"
    elif [[ -f /etc/NIXOS ]]; then
        CONFIG_TYPE="nixos"
    elif [[ -n "${NIX_PATH:-}" ]] || command -v nix &>/dev/null; then
        CONFIG_TYPE="home-manager"
    else
        print_error "Could not detect system type or Nix installation"
        exit 1
    fi
    
    printf "Detected system type: %s\n" "${CONFIG_TYPE}"
}

verify_not_root() {
    if [[ "${EUID}" -eq 0 ]]; then
        print_error "Do not run this script as root"
        exit 1
    fi
}

verify_required_tools() {
    local missing_tools=()
    local tool
    local required_tools=(git nix jq curl)
    
    case "${CONFIG_TYPE}" in
        darwin)
            required_tools+=(darwin-rebuild)
            ;;
        nixos)
            required_tools+=(nixos-rebuild)
            ;;
        home-manager)
            required_tools+=(home-manager)
            ;;
    esac
    
    for tool in "${required_tools[@]}"; do
        if ! command -v "${tool}" &>/dev/null; then
            missing_tools+=("${tool}")
        fi
    done
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        print_error "Required tools are missing: ${missing_tools[*]}"
        exit 1
    fi
}

parse_flags() {
    cleanup=false
    while [[ $# -gt 0 ]]; do
        case $1 in
            --cleanup)
                cleanup=true
                shift
                ;;
            *)
                printf "Unknown option: %s\n" "$1"
                printf "Usage: %s [--cleanup]\n" "$0"
                exit 1
                ;;
        esac
    done
}

check_network() {
    print_header "Checking network connectivity..."

    if curl --silent --fail --max-time 5 --head https://cache.nixos.org &>/dev/null; then
        printf "Network connectivity verified ✓\n"
        return 0
    fi

    print_error "Cannot reach cache.nixos.org via HTTPS. Cannot proceed with updates."
    exit 1
}

### Main functions ###

update_dotfiles() {
    print_header "Updating dotfiles..."

    # Check for uncommitted changes
    if ! git -C "${dotfiles_path}" diff-index --quiet HEAD --; then
        print_warning "Dotfiles have uncommitted changes. Skipping pull step."
    else
        run_logged "dotfiles" "Dotfiles updated" \
            git -C "${dotfiles_path}" pull
    fi
}

update_flake_inputs() {
    print_header "Updating config flake inputs..."
    run_logged "flake" "Flake inputs updated" \
        nix flake update --flake "${flake_path}"
}

detect_and_verify_config() {
    local config_attr
    local config_key
    local eval_test
    
    case "${CONFIG_TYPE}" in
        darwin)
            config_attr="darwinConfigurations"
            config_key="${hostname}"
            eval_test="${flake_path}#${config_attr}.${config_key}.config.system.stateVersion"
            ;;
        nixos)
            config_attr="nixosConfigurations"
            config_key="${hostname}"
            eval_test="${flake_path}#${config_attr}.${config_key}.config.system.stateVersion"
            ;;
        home-manager)
            config_attr="homeConfigurations"
            config_key="${username}@${hostname}"
            eval_test="${flake_path}#${config_attr}.\"${config_key}\".config.home.stateVersion"
            ;;
    esac
    
    # Verify the configuration exists in the flake
    if ! nix eval "${eval_test}" &>/dev/null; then
        print_error "Configuration '${config_key}' not found in ${config_attr}"
        printf "Available configurations:\n"
        nix eval --json "${flake_path}#${config_attr}" --apply 'builtins.attrNames' 2>/dev/null | \
            jq -r '.[]' | sed 's/^/  - /' || \
            printf "  (Unable to list configurations)\n"
        exit 1
    fi
}

rebuild_system() {
    print_header "Rebuilding and applying config flake..."
    
    local profile_path
    local config_key
    
    case "${CONFIG_TYPE}" in
        darwin)
            profile_path="/nix/var/nix/profiles/system"
            config_key="${hostname}"
            ;;
        nixos)
            profile_path="/nix/var/nix/profiles/system"
            config_key="${hostname}"
            ;;
        home-manager)
            profile_path="${HOME}/.local/state/nix/profiles/home-manager"
            config_key="${username}@${hostname}"
            ;;
    esac
    
    # Get current generation
    local current_gen
    current_gen=$(readlink "${profile_path}" 2>/dev/null | grep -o '[0-9]\+' || echo "unknown")
    printf "Current generation: %s\n" "${current_gen}"
    
    # Run the appropriate rebuild command
    case "${CONFIG_TYPE}" in
        darwin)
            run_logged "rebuild" "System rebuilt successfully" \
                sudo darwin-rebuild switch --flake "${flake_path}#${config_key}"
            ;;
        nixos)
            run_logged "rebuild" "System rebuilt successfully" \
                sudo nixos-rebuild switch --flake "${flake_path}#${config_key}"
            ;;
        home-manager)
            run_logged "rebuild" "System rebuilt successfully" \
                home-manager switch --flake "${flake_path}#${config_key}"
            ;;
    esac
    
    # Show new generation
    local new_gen
    new_gen=$(readlink "${profile_path}" 2>/dev/null | grep -o '[0-9]\+' || echo "unknown")
    printf "New generation: %s\n" "${new_gen}"
}

run_cleanup() {
    if [[ "${cleanup}" = true ]]; then
        print_header "Running nix garbage collection..."
        run_logged "gc" "Garbage collection completed" \
            nix-collect-garbage -d

        print_header "Optimizing nix store..."
        run_logged "optimize" "Store optimization completed" \
            nix store optimise
    else
        printf "\nSkipping cleanup (use --cleanup to enable)\n"
    fi
}

### Main execution ###

verify_not_root
detect_system_type
verify_required_tools
parse_flags "$@"
check_network
update_dotfiles
update_flake_inputs
detect_and_verify_config
rebuild_system
run_cleanup

if [[ -d "${log_dir}" ]] && [[ -n "$(ls -A "${log_dir}" 2>/dev/null || true)" ]]; then
    printf "\nLogs saved to: %s\n" "${log_dir}"
fi
