#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

# Determine flake path: use the directory containing this script
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
flake_path="$(cd "${script_dir}/.." && pwd)"

hostname=$(hostname -s)
username="${USER}"

# Set log directory based on OS
if [[ "$(uname)" == "Darwin" ]]; then
    log_dir="${HOME}/Library/Logs/system-update/$(date +%Y%m%d-%H%M%S)"
else
    log_dir="${HOME}/.local/state/system-update/$(date +%Y%m%d-%H%M%S)"
fi

CONFIG_TYPE=""


print_header() {
    printf "\n\033[1m>> %s\033[0m\n" "$1"
}

print_error() {
    printf "\n\033[1;31m✗ Error: %s\033[0m\n" "$1" >&2
}

print_warning() {
    printf "\033[1;33m⚠ Warning: %s\033[0m\n" "$1"
}

run_logged() {
    local operation_name="$1"
    local success_msg="$2"
    shift 2

    mkdir -p "${log_dir}"
    local log_file
    log_file="${log_dir}/${operation_name}.log"

    if "$@" > "${log_file}" 2>&1; then
        printf "✓ %s\n" "${success_msg}"
    else
        print_error "${operation_name} failed"
        tail -n 30 "${log_file}"
        printf "\nFull log: %s\n" "${log_file}"
        exit 1
    fi
}

### Pre-run checks ###

detect_system_type() {
    if [[ "$(uname)" == "Darwin" ]]; then
        CONFIG_TYPE="darwin"
    elif [[ -f /etc/NIXOS ]]; then
        CONFIG_TYPE="nixos"
    elif [[ -n "${NIX_PATH:-}" ]] || command -v nix &>/dev/null; then
        CONFIG_TYPE="home-manager"
    else
        print_error "Could not detect system type or Nix installation"
        exit 1
    fi
}

verify_not_root() {
    if [[ "${EUID}" -eq 0 ]]; then
        print_error "Do not run this script as root"
        exit 1
    fi
}

verify_required_tools() {
    local missing_tools=()
    local tool
    local required_tools=(git nix jq curl)

    case "${CONFIG_TYPE}" in
        darwin)
            required_tools+=(darwin-rebuild)
            ;;
        nixos)
            required_tools+=(nixos-rebuild)
            ;;
        home-manager)
            required_tools+=(home-manager)
            ;;
    esac

    for tool in "${required_tools[@]}"; do
        if ! command -v "${tool}" &>/dev/null; then
            missing_tools+=("${tool}")
        fi
    done

    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        print_error "Required tools are missing: ${missing_tools[*]}"
        exit 1
    fi
}

parse_flags() {
    cleanup=false
    while [[ $# -gt 0 ]]; do
        case $1 in
            --cleanup)
                cleanup=true
                shift
                ;;
            *)
                printf "Unknown option: %s\n" "$1"
                printf "Usage: %s [--cleanup]\n" "$0"
                exit 1
                ;;
        esac
    done
}

check_network() {
    if ! curl --silent --fail --max-time 5 --head https://cache.nixos.org &>/dev/null; then
        print_error "Cannot reach cache.nixos.org via HTTPS. Cannot proceed with updates."
        exit 1
    fi
}

check_disk_space() {
    # Minimum required free space: 5 GiB = 5 * 1024 * 1024 KiB
    local min_free_kb=5242880

    # Get available space in kilobytes (using -P for portable, single-line output)
    local available_kb
    available_kb=$(df -Pk /nix 2>/dev/null | tail -1 | awk '{print $4}')

    if [[ -z "${available_kb}" ]]; then
        print_error "Failed to check disk space for /nix"
        exit 1
    fi

    if [[ "${available_kb}" -lt "${min_free_kb}" ]]; then
        local available_gb=$((available_kb / 1024 / 1024))
        local min_free_gb=$((min_free_kb / 1024 / 1024))
        local nix_mount_point
        nix_mount_point=$(df -P /nix 2>/dev/null | tail -1 | awk '{print $1}')
        print_error "Insufficient disk space: ${available_gb} GiB available on ${nix_mount_point}, ${min_free_gb} GiB required"
        printf "\nConsider running: nix-collect-garbage -d\n"
        printf "Or use --cleanup flag when running this script\n"
        exit 1
    fi
}

### Main functions ###

update_dotfiles() {
    print_header "Updating dotfiles..."

    # Check for uncommitted changes (git pull requires clean working directory)
    if ! git -C "${flake_path}" diff-index --quiet HEAD --; then
        print_warning "Dotfiles have uncommitted changes. Skipping pull step."
        return
    fi

    # Pull using configured strategy (respects pull.rebase setting)
    # Git handles: fetching, checking for updates, merging/rebasing, conflict detection
    run_logged "dotfiles" "Dotfiles updated" \
        git -C "${flake_path}" pull
}

update_flake_inputs() {
    print_header "Updating config flake inputs..."
    run_logged "flake" "Flake inputs updated" \
        nix flake update --flake "${flake_path}"
}

detect_and_verify_config() {
    local config_attr
    local config_key
    local eval_test

    case "${CONFIG_TYPE}" in
        darwin)
            config_attr="darwinConfigurations"
            config_key="${hostname}"
            eval_test="${flake_path}#${config_attr}.${config_key}.config.system.stateVersion"
            ;;
        nixos)
            config_attr="nixosConfigurations"
            config_key="${hostname}"
            eval_test="${flake_path}#${config_attr}.${config_key}.config.system.stateVersion"
            ;;
        home-manager)
            config_attr="homeConfigurations"
            config_key="${username}@${hostname}"
            eval_test="${flake_path}#${config_attr}.\"${config_key}\".config.home.stateVersion"
            ;;
    esac

    # Verify the configuration exists in the flake
    if ! nix eval "${eval_test}" &>/dev/null; then
        print_error "Configuration '${config_key}' not found in ${config_attr}"
        printf "Available configurations:\n"
        nix eval --json "${flake_path}#${config_attr}" --apply 'builtins.attrNames' 2>/dev/null | \
            jq -r '.[]' | sed 's/^/  - /' || \
            printf "  (Unable to list configurations)\n"
        exit 1
    fi
}

show_store_size() {
    local current_path="$1"
    local result_path="$2"

    # Get current closure size
    local current_size current_size_mb
    if [[ -n "${current_path}" ]] && [[ -e "${current_path}" ]]; then
        current_size=$(nix path-info --closure-size "${current_path}" 2>/dev/null | tail -1 | awk '{print $2}')
        current_size_mb=$((current_size / 1024 / 1024))
    else
        current_size=0
        current_size_mb=0
    fi

    # Get new closure size
    local new_size new_size_mb
    if [[ -n "${result_path}" ]] && [[ -e "${result_path}" ]]; then
        new_size=$(nix path-info --closure-size "${result_path}" 2>/dev/null | tail -1 | awk '{print $2}')
        new_size_mb=$((new_size / 1024 / 1024))
    else
        return 0
    fi

    # Only show difference if there's a meaningful change
    if [[ "${current_size}" -gt 0 ]] && [[ "${new_size}" -gt 0 ]]; then
        local diff_mb=$((new_size_mb - current_size_mb))

        if [[ "${diff_mb}" -gt 0 ]]; then
            printf "Store size change: +%s MiB\n" "${diff_mb}"
        elif [[ "${diff_mb}" -lt 0 ]]; then
            printf "Store size change: %s MiB smaller\n" "${diff_mb#-}"
        fi
    fi
}

rebuild_system() {
    print_header "Building config flake..."

    local profile_path
    local config_key
    local build_cmd
    local switch_cmd

    case "${CONFIG_TYPE}" in
        darwin)
            profile_path="/nix/var/nix/profiles/system"
            config_key="${hostname}"
            build_cmd=(sudo darwin-rebuild build --flake "${flake_path}#${config_key}")
            switch_cmd=(sudo darwin-rebuild switch --flake "${flake_path}#${config_key}")
            ;;
        nixos)
            profile_path="/nix/var/nix/profiles/system"
            config_key="${hostname}"
            build_cmd=(sudo nixos-rebuild build --flake "${flake_path}#${config_key}")
            switch_cmd=(sudo nixos-rebuild switch --flake "${flake_path}#${config_key}")
            ;;
        home-manager)
            profile_path="${HOME}/.local/state/nix/profiles/home-manager"
            config_key="${username}@${hostname}"
            build_cmd=(home-manager build --flake "${flake_path}#${config_key}")
            switch_cmd=(home-manager switch --flake "${flake_path}#${config_key}")
            ;;
    esac

    # Build the new configuration
    run_logged "build" "Build completed successfully" \
        "${build_cmd[@]}"

    # Compare the built result to the current generation
    local result_path
    result_path=$(readlink -f "${flake_path}/result" 2>/dev/null || echo "")
    local current_path
    current_path=$(readlink -f "${profile_path}" 2>/dev/null || echo "")

    if [[ -n "${result_path}" ]] && [[ "${result_path}" == "${current_path}" ]]; then
        printf "✓ No changes detected, skipping activation\n"
        # Clean up result symlink
        rm -f "${flake_path}/result"
        return 0
    fi

    # Show current generation
    local current_gen
    current_gen=$(readlink "${profile_path}" 2>/dev/null | grep -o '[0-9]\+' || echo "unknown")
    printf "Current generation: %s\n" "${current_gen}"

    # Show store space comparison (only if there are changes)
    show_store_size "${current_path}" "${result_path}"

    # Apply the new configuration
    print_header "Activating new configuration..."
    run_logged "switch" "System activated successfully" \
        "${switch_cmd[@]}"

    # Clean up result symlink (switch creates its own)
    rm -f "${flake_path}/result"

    # Show new generation
    local new_gen
    new_gen=$(readlink "${profile_path}" 2>/dev/null | grep -o '[0-9]\+' || echo "unknown")
    printf "New generation: %s\n" "${new_gen}"
}

run_cleanup() {
    if [[ "${cleanup}" = true ]]; then
        print_header "Running nix garbage collection..."
        run_logged "gc" "Garbage collection completed" \
            nix-collect-garbage -d

        print_header "Optimizing nix store..."
        run_logged "optimize" "Store optimization completed" \
            nix store optimise
    else
        printf "\nSkipping cleanup (use --cleanup to enable)\n"
    fi
}

### Main execution ###

verify_not_root
detect_system_type
verify_required_tools
parse_flags "$@"
check_network
check_disk_space
update_dotfiles
update_flake_inputs
detect_and_verify_config
rebuild_system
run_cleanup

if [[ -d "${log_dir}" ]] && [[ -n "$(ls -A "${log_dir}" 2>/dev/null || true)" ]]; then
    printf "\nLogs saved to: %s\n" "${log_dir}"
fi
